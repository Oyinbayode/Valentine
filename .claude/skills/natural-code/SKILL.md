---
name: natural-code
description: Write and review code that avoids telltale AI-generated patterns. Use when writing new code, reviewing code, refactoring, or when the user asks for "natural" or "human-like" code. Produces cleaner, more maintainable code by avoiding over-commenting, hallucinated APIs, generic naming, and other AI anti-patterns.
---

# Natural Code

Write code that reads like it was crafted by an experienced developer, not generated by AI.

## Core Principles

### 1. Minimal Comments

- **Don't comment what the code already says.** If `getUserById(id)` is clear, don't add `// Gets user by ID`
- **Only comment the "why", never the "what"** — explain non-obvious business logic, workarounds, or edge cases
- **No section dividers** like `// ===== HELPERS =====` or `// --- API CALLS ---`
- **No trailing comments** on obvious lines

```typescript
// ❌ AI pattern
// Function to calculate the total price
function calculateTotalPrice(items: Item[]): number {
  // Initialize total to zero
  let total = 0;
  // Loop through each item
  for (const item of items) {
    // Add the item price to total
    total += item.price;
  }
  // Return the final total
  return total;
}

// ✅ Natural
function calculateTotalPrice(items: Item[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### 2. Specific, Contextual Naming

- Avoid generic names: `data`, `result`, `response`, `item`, `temp`, `value`, `info`
- Use domain-specific names: `user`, `order`, `cartItems`, `invoiceTotal`
- Function names should reveal intent, not implementation

```typescript
// ❌ AI pattern
const data = await fetchData();
const result = processData(data);
const items = result.filter((item) => item.value > 0);

// ✅ Natural
const orders = await fetchPendingOrders();
const enrichedOrders = attachCustomerDetails(orders);
const billableOrders = enrichedOrders.filter((order) => order.total > 0);
```

### 3. Verify APIs and Packages Exist

Before using any API, method, or package:

- Confirm the function signature matches current documentation
- Check the package exists in the registry (npm, PyPI, etc.)
- Verify import paths are correct

Common hallucination patterns:

- `array.filterMap()` — doesn't exist
- `string.isBlank()` — doesn't exist in JS
- Made-up utility packages with plausible names

### 4. Match Existing Codebase Patterns

When working in an existing project:

- Use the same error handling approach
- Follow established naming conventions
- Match the abstraction level of surrounding code
- Don't introduce new patterns without reason

### 5. Handle Edge Cases Explicitly

AI often handles the happy path but misses:

- Null/undefined inputs
- Empty arrays or strings
- Network failures
- Invalid data formats
- Boundary conditions

```typescript
// ❌ AI pattern — assumes happy path
function getFirstUser(users: User[]) {
  return users[0].name;
}

// ✅ Natural — handles edges
function getFirstUser(users: User[]): string | null {
  return users[0]?.name ?? null;
}
```

### 6. Avoid Performance Anti-Patterns

- Prefer `O(n)` or `O(n log n)` over nested loops `O(n²)`
- Use `Map`/`Set` for lookups instead of repeated `array.find()`
- Batch database queries — avoid N+1 patterns
- Use async/await appropriately for I/O operations

### 7. Modern Patterns Over Deprecated Ones

- Functional components + hooks over class components (React)
- `async/await` over `.then()` chains
- `const`/`let` over `var`
- Template literals over string concatenation
- Optional chaining over nested conditionals

### 8. No Over-Engineering

- Don't abstract until there's repetition
- Avoid premature generalization
- Skip unnecessary interfaces for single implementations
- Don't add "just in case" parameters

### 9. No Hacky Type Workarounds

When encountering type errors:

- **Find and fix the root cause** — trace the type mismatch to its source
- **Or leave it alone** — unless explicitly asked to fix it
- **Never suppress with hacks:**
  - No `as any` or `as unknown`
  - No `typeof` checks just to satisfy the compiler
  - No `// @ts-ignore` or `// @ts-expect-error`
  - No unnecessary type assertions

```typescript
// ❌ AI pattern — hacky workaround
function processUser(user: User) {
  if (typeof user.name === "string") {
    // unnecessary if type is correct
    return user.name.toUpperCase();
  }
}

const data = response as any; // hiding the real problem

// ✅ Natural — fix the actual type
function processUser(user: User) {
  return user.name.toUpperCase();
}

const data: ApiResponse = response; // properly typed
```

## When Reviewing Code

Flag these AI tells:

1. Every function has a comment restating its name
2. Generic variable names throughout
3. Suspiciously perfect formatting with unusual consistency
4. Over-defensive coding without clear threat model
5. Unfamiliar packages or methods (verify they exist)
6. Code that doesn't match the project's existing style
